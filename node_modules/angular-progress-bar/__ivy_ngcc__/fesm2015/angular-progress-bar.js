import { Component, Input, NgModule, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function ProgressBarComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.whichProgress(ctx_r0.progress), "% ");
} }
function ProgressBarComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.whichProgress(ctx_r1.progress), " ");
} }
class ProgressBarComponent {
    constructor() {
        // Default color
        this.color = "#488aff";
        this.disabledP = false;
    }
    /**
     * Returns a color for a certain percent
     * @param {?} percent The current progress
     * @return {?}
     */
    whichColor(percent) {
        // Get all entries index as an array
        /** @type {?} */
        let k = Object.keys(this.degraded);
        // Convert string to number
        k.forEach((e, i) => k[i] = +e);
        // Sort them by value
        k = k.sort((a, b) => a - b);
        // Percent as number
        /** @type {?} */
        let p = +percent
        // Set last by default as the first occurrence
        ;
        // Set last by default as the first occurrence
        /** @type {?} */
        let last = k[0];
        // Foreach keys 
        for (let val of k) {
            // if current val is < than percent
            if (val < p) {
                last = val;
            }
            // if val >= percent then the val that we could show has been reached
            else if (val >= p - 1) {
                return this.degraded[last];
            }
        }
        // if its the last one return the last
        return this.degraded[last];
    }
    /**
     * @param {?} progress
     * @return {?}
     */
    whichProgress(progress) {
        try {
            return Math.round(+progress * 100) / 100;
        }
        catch (_a) {
            return progress;
        }
    }
}
ProgressBarComponent.ɵfac = function ProgressBarComponent_Factory(t) { return new (t || ProgressBarComponent)(); };
ProgressBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ProgressBarComponent, selectors: [["progress-bar"]], inputs: { color: "color", disabledP: ["disable-percentage", "disabledP"], progress: "progress", degraded: ["color-degraded", "degraded"] }, decls: 4, vars: 6, consts: [[1, "progress-outer"], [1, "progress-inner"], [4, "ngIf"]], template: function ProgressBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵtemplate(2, ProgressBarComponent_ng_container_2_Template, 2, 1, "ng-container", 2);
        ɵngcc0.ɵɵtemplate(3, ProgressBarComponent_ng_container_3_Template, 2, 1, "ng-container", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.whichProgress(ctx.progress) + "%")("background-color", ctx.degraded == null ? ctx.color : ctx.whichColor(ctx.progress));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.disabledP);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.disabledP);
    } }, directives: [ɵngcc1.NgIf], styles: [".progress-outer[_ngcontent-%COMP%] {\n          width: 96%;\n          margin: 10px 2%;\n          padding: 3px;\n          background-color: #f4f4f4;\n          border: 1px solid #dcdcdc;\n          color: #fff;\n          border-radius: 20px;\n          text-align: center;\n        }\n        .progress-inner[_ngcontent-%COMP%] {\n          min-width: 15%;\n          min-height:18px;\n          white-space: nowrap;\n          overflow: hidden;\n          padding: 0px;\n          border-radius: 20px;"] });
/** @nocollapse */
ProgressBarComponent.ctorParameters = () => [];
ProgressBarComponent.propDecorators = {
    progress: [{ type: Input, args: ['progress',] }],
    color: [{ type: Input, args: ['color',] }],
    degraded: [{ type: Input, args: ['color-degraded',] }],
    disabledP: [{ type: Input, args: ['disable-percentage',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ProgressBarComponent, [{
        type: Component,
        args: [{
                selector: 'progress-bar',
                template: `
  <div class=\"progress-outer\">
    <div class=\"progress-inner\" [style.width]=\"whichProgress(progress) + '%'\" [style.background-color]=\"degraded == null ? color : whichColor(progress)\">
      <ng-container *ngIf="!disabledP"> 
        {{whichProgress(progress)}}%
      </ng-container>
      <ng-container *ngIf="disabledP"> 
        {{whichProgress(progress)}}
      </ng-container>
    </div>
  </div>
  `,
                styles: [`
        .progress-outer {
          width: 96%;
          margin: 10px 2%;
          padding: 3px;
          background-color: #f4f4f4;
          border: 1px solid #dcdcdc;
          color: #fff;
          border-radius: 20px;
          text-align: center;
        }
        .progress-inner {
          min-width: 15%;
          min-height:18px;
          white-space: nowrap;
          overflow: hidden;
          padding: 0px;
          border-radius: 20px;
  `]
            }]
    }], function () { return []; }, { color: [{
            type: Input,
            args: ['color']
        }], disabledP: [{
            type: Input,
            args: ['disable-percentage']
        }], progress: [{
            type: Input,
            args: ['progress']
        }], degraded: [{
            type: Input,
            args: ['color-degraded']
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProgressBarModule {
}
ProgressBarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ProgressBarModule });
ProgressBarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ProgressBarModule_Factory(t) { return new (t || ProgressBarModule)(); }, imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ProgressBarModule, { declarations: function () { return [ProgressBarComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [ProgressBarComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ProgressBarModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [ProgressBarComponent],
                exports: [ProgressBarComponent],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ProgressBarComponent, ProgressBarModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1wcm9ncmVzcy1iYXIuanMiLCJzb3VyY2VzIjpbImFuZ3VsYXItcHJvZ3Jlc3MtYmFyL2xpYi9hbmd1bGFyLXByb2dyZXNzLWJhci5jb21wb25lbnQudHMiLCJhbmd1bGFyLXByb2dyZXNzLWJhci9saWIvYW5ndWxhci1wcm9ncmVzcy1iYXIubW9kdWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQXNDYSxvQkFBb0I7QUFDakMsSUFRQTtBQUNBO0FBQ00sUUFBSixJQUFJLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQztBQUN6QixRQUFFLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO0FBQ3pCLEtBQUM7QUFDRDtBQUVFO0FBQ0k7QUFFRztBQUFvQjtBQUNyQixJQURSLFVBQVUsQ0FBQyxPQUFlO0FBQ3pCO0FBQ007QUFBMEIsWUFBM0IsQ0FBQyxHQUFlLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztBQUNoRDtBQUNNLFFBQUosQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDakM7QUFDTSxRQUFKLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDOUI7QUFDTTtBQUNNLFlBRE4sQ0FBQyxHQUFHLENBQUMsT0FBTztBQUNsQjtBQUNNO0FBQVc7QUFHTjtBQUEwQixZQUgvQixJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNqQjtBQUNNLFFBQUosS0FBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLEVBQUM7QUFDbkI7QUFDUSxZQUFKLElBQUcsR0FBRyxHQUFHLENBQUMsRUFBQztBQUNmLGdCQUFNLElBQUksR0FBRyxHQUFHLENBQUM7QUFDakIsYUFBSztBQUNMO0FBQ1EsaUJBQUMsSUFBRyxHQUFHLElBQUksQ0FBQyxHQUFFLENBQUMsRUFBQztBQUN4QixnQkFBTSxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDakMsYUFBSztBQUNMLFNBQUc7QUFDSDtBQUNNLFFBQUosT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzdCLEtBQUM7QUFDRDtBQUNPO0FBQ047QUFDWTtBQUFTLElBRnRCLGFBQWEsQ0FBQyxRQUFnQjtBQUM3QixRQUFDLElBQUc7QUFDTCxZQUFJLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDN0MsU0FBRztBQUNILFFBQUUsV0FBSztBQUNQLFlBQUksT0FBTyxRQUFRLENBQUM7QUFDcEIsU0FBRztBQUNILEtBQUM7QUFDRDtrREF6RkMsU0FBUyxTQUFDLG1CQUNULFFBQVEsRUFDSixjQUFjO2NBb0JsQixRQUFRLEVBQ1I7bUNBV0M7bUJBL0JROzs7Ozs7O2lKQWtCUjtBQWNGOzs7OzZpQkFDRztBQUFFO0FBQW9CO0FBR047QUFDQyx1QkFEbEIsS0FBSyxTQUFDLFVBQVU7QUFBUSxvQkFDeEIsS0FBSyxTQUFDLE9BQU87QUFBUSx1QkFDckIsS0FBSyxTQUFDLGdCQUFnQjtBQUFRLHdCQUM5QixLQUFLLFNBQUMsb0JBQW9CO0FBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFBQztBQUFDO0FBQUs7QUFJdEM7QUFNa0I7QUN0RHpCLE1BYWEsaUJBQWlCO0FBQUk7K0NBUmpDLFFBQVEsU0FBQztJQUNSLE9BQU8sRUFBRSx1QkFDUCxZQUFZLG1CQUNiLG1CQUNELFlBQVksRUFBRSxDQUFDLG9CQUFvQixDQUFDLG1CQUNwQyxPQUFPLEVBQUUsQ0FBQztpQkFBb0IsQ0FBQztZQUMvQjtJQUFPLEVBQUUsQ0FBQyxzQkFBc0IsQ0FBQyxlQUNsQzs7Ozs7Ozs7Ozs7MEJBQ0k7QUFBQztBQUFDO0FBQUs7QUFBbUM7QUFBc0c7QUFBSTtBQUFDO0FBQUs7QUFBbUM7QUFBc0c7QUFBSTtBQUFDOztBRGJBLEFBc0NBLEFBQUEsQUFTQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQU1BLEFBQUEsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQ0EsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQ0EsQUF4RkEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFvQkEsQUFBQSxBQUNBLEFBV0EsQUEvQkEsQUFrQkEsQUFjQSxBQUlBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFDNUNBLEFBYUEsQUFBQSxBQVJBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6XHJcbiAgICAgICdwcm9ncmVzcy1iYXInLFxyXG4gIHN0eWxlczogW2BcclxuICAgICAgICAucHJvZ3Jlc3Mtb3V0ZXIge1xyXG4gICAgICAgICAgd2lkdGg6IDk2JTtcclxuICAgICAgICAgIG1hcmdpbjogMTBweCAyJTtcclxuICAgICAgICAgIHBhZGRpbmc6IDNweDtcclxuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmNGY0ZjQ7XHJcbiAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjZGNkY2RjO1xyXG4gICAgICAgICAgY29sb3I6ICNmZmY7XHJcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiAyMHB4O1xyXG4gICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAucHJvZ3Jlc3MtaW5uZXIge1xyXG4gICAgICAgICAgbWluLXdpZHRoOiAxNSU7XHJcbiAgICAgICAgICBtaW4taGVpZ2h0OjE4cHg7XHJcbiAgICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xyXG4gICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuICAgICAgICAgIHBhZGRpbmc6IDBweDtcclxuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDIwcHg7XHJcbiAgYF0sXHJcbiAgdGVtcGxhdGU6XHJcbiAgYFxyXG4gIDxkaXYgY2xhc3M9XFxcInByb2dyZXNzLW91dGVyXFxcIj5cclxuICAgIDxkaXYgY2xhc3M9XFxcInByb2dyZXNzLWlubmVyXFxcIiBbc3R5bGUud2lkdGhdPVxcXCJ3aGljaFByb2dyZXNzKHByb2dyZXNzKSArICclJ1xcXCIgW3N0eWxlLmJhY2tncm91bmQtY29sb3JdPVxcXCJkZWdyYWRlZCA9PSBudWxsID8gY29sb3IgOiB3aGljaENvbG9yKHByb2dyZXNzKVxcXCI+XHJcbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhZGlzYWJsZWRQXCI+IFxyXG4gICAgICAgIHt7d2hpY2hQcm9ncmVzcyhwcm9ncmVzcyl9fSVcclxuICAgICAgPC9uZy1jb250YWluZXI+XHJcbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJkaXNhYmxlZFBcIj4gXHJcbiAgICAgICAge3t3aGljaFByb2dyZXNzKHByb2dyZXNzKX19XHJcbiAgICAgIDwvbmctY29udGFpbmVyPlxyXG4gICAgPC9kaXY+XHJcbiAgPC9kaXY+XHJcbiAgYFxyXG59KVxyXG5leHBvcnQgY2xhc3MgUHJvZ3Jlc3NCYXJDb21wb25lbnQge1xyXG5cclxuLyoqIElucHV0cyAqKi9cclxuICBASW5wdXQoJ3Byb2dyZXNzJykgcHJvZ3Jlc3M6IHN0cmluZztcclxuICBASW5wdXQoJ2NvbG9yJykgY29sb3I6IHN0cmluZztcclxuICBASW5wdXQoJ2NvbG9yLWRlZ3JhZGVkJykgZGVncmFkZWQ6IGFueTtcclxuICBASW5wdXQoJ2Rpc2FibGUtcGVyY2VudGFnZScpIGRpc2FibGVkUDogYm9vbGVhbjtcclxuXHJcblxyXG5jb25zdHJ1Y3RvcigpIHtcclxuICAvLyBEZWZhdWx0IGNvbG9yXHJcbiAgdGhpcy5jb2xvciA9IFwiIzQ4OGFmZlwiO1xyXG4gIHRoaXMuZGlzYWJsZWRQID0gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY29sb3IgZm9yIGEgY2VydGFpbiBwZXJjZW50XHJcbiAqIEBwYXJhbSBwZXJjZW50IFRoZSBjdXJyZW50IHByb2dyZXNzXHJcbiAqL1xyXG53aGljaENvbG9yKHBlcmNlbnQ6IHN0cmluZyl7XHJcbiAgLy8gR2V0IGFsbCBlbnRyaWVzIGluZGV4IGFzIGFuIGFycmF5XHJcbiAgbGV0IGs6IEFycmF5PGFueT4gPSBPYmplY3Qua2V5cyh0aGlzLmRlZ3JhZGVkKTtcclxuICAvLyBDb252ZXJ0IHN0cmluZyB0byBudW1iZXJcclxuICBrLmZvckVhY2goKGUsIGkpID0+IGtbaV0gPSArZSk7XHJcbiAgLy8gU29ydCB0aGVtIGJ5IHZhbHVlXHJcbiAgayA9IGsuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG4gIC8vIFBlcmNlbnQgYXMgbnVtYmVyXHJcbiAgbGV0IHAgPSArcGVyY2VudFxyXG4gIC8vIFNldCBsYXN0IGJ5IGRlZmF1bHQgYXMgdGhlIGZpcnN0IG9jY3VycmVuY2VcclxuICBsZXQgbGFzdCA9IGtbMF07XHJcbiAgLy8gRm9yZWFjaCBrZXlzIFxyXG4gIGZvcihsZXQgdmFsIG9mIGspe1xyXG4gICAgLy8gaWYgY3VycmVudCB2YWwgaXMgPCB0aGFuIHBlcmNlbnRcclxuICAgIGlmKHZhbCA8IHApe1xyXG4gICAgICBsYXN0ID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgdmFsID49IHBlcmNlbnQgdGhlbiB0aGUgdmFsIHRoYXQgd2UgY291bGQgc2hvdyBoYXMgYmVlbiByZWFjaGVkXHJcbiAgICBlbHNlIGlmKHZhbCA+PSBwIC0xKXtcclxuICAgICAgcmV0dXJuIHRoaXMuZGVncmFkZWRbbGFzdF07XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIGlmIGl0cyB0aGUgbGFzdCBvbmUgcmV0dXJuIHRoZSBsYXN0XHJcbiAgcmV0dXJuIHRoaXMuZGVncmFkZWRbbGFzdF07XHJcbn1cclxuXHJcbndoaWNoUHJvZ3Jlc3MocHJvZ3Jlc3M6IHN0cmluZyl7XHJcbiAgdHJ5e1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQoK3Byb2dyZXNzICogMTAwKSAvIDEwMDtcclxuICB9XHJcbiAgY2F0Y2h7XHJcbiAgICByZXR1cm4gcHJvZ3Jlc3M7XHJcbiAgfVxyXG59XHJcbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBQcm9ncmVzc0JhckNvbXBvbmVudCB9IGZyb20gJy4vYW5ndWxhci1wcm9ncmVzcy1iYXIuY29tcG9uZW50JztcclxuaW1wb3J0IHsgQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tIFwiQGFuZ3VsYXIvY29tbW9uXCI7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gIGltcG9ydHM6IFtcclxuICAgIENvbW1vbk1vZHVsZVxyXG4gIF0sXHJcbiAgZGVjbGFyYXRpb25zOiBbUHJvZ3Jlc3NCYXJDb21wb25lbnRdLFxyXG4gIGV4cG9ydHM6IFtQcm9ncmVzc0JhckNvbXBvbmVudF0sXHJcbiAgc2NoZW1hczogW0NVU1RPTV9FTEVNRU5UU19TQ0hFTUFdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBQcm9ncmVzc0Jhck1vZHVsZSB7IH0iXX0=